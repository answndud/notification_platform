# Chapter 22 - 캐시 패턴

- 상태: 초안 완료
- 목표 분량: 9쪽

## 학습 목표

- 대표 캐시 패턴을 구분할 수 있다.
- 서비스 특성에 맞는 패턴을 선택할 수 있다.
- 패턴별 실패 지점을 예측할 수 있다.

## 핵심 패턴

### Cache-Aside

- 애플리케이션이 캐시 miss 시 DB 조회 후 캐시에 저장
- 가장 보편적이며 구현이 단순

읽기 트래픽이 압도적으로 많은 서비스에서 가장 먼저 검토하는 패턴입니다.
단, 데이터 갱신 경로에서 무효화 누락이 발생하면 stale 데이터가 길게 남을 수 있습니다.

### Read-Through

- 캐시 계층이 DB 조회를 대행
- 애플리케이션 코드 단순화 가능

캐시 계층이 표준화된 플랫폼 환경에서는 유리하지만,
애플리케이션이 제어 가능한 영역이 줄어 디버깅 복잡도가 오를 수 있습니다.

### Write-Through

- 쓰기를 캐시와 원본 저장소에 동기 반영
- 일관성은 좋지만 쓰기 지연 증가 가능

주문/결제처럼 "쓰기 직후 읽기 일관성"이 중요한 경우 유용합니다.
대신 장애 시 이중 쓰기 실패 시나리오를 반드시 설계해야 합니다.

### Write-Behind

- 캐시에 먼저 쓰고 원본 저장소 반영을 지연
- 고성능 가능하지만 장애 시 손실 위험 설계 필요

대량 쓰기 처리량을 높일 수 있지만,
원본 반영 지연 구간에서 데이터 신뢰성 요구가 높은 도메인에는 신중해야 합니다.

## 패턴 선택 프레임워크

아래 네 가지 질문으로 빠르게 후보를 줄일 수 있습니다.

1. 읽기/쓰기 비율은 어떤가?
2. stale 데이터 허용 시간은 얼마인가?
3. 장애 시 데이터 손실 허용 범위는 얼마인가?
4. 운영팀이 감당 가능한 복잡도는 어느 수준인가?

## 실습 예제(개념)

```text
if cache hit:
  return cached value
else:
  load from db
  set cache with ttl
  return value
```

## 설계 포인트

- 조회 비중이 높으면 Cache-Aside 우선 검토
- 강한 쓰기 일관성이 필요하면 Write-Through 고려
- 패턴 선택 시 장애 시 동작까지 포함해서 결정

실무 권장 시작점:

- 1단계: Cache-Aside + 짧은 TTL + 명시적 무효화
- 2단계: 병목 구간만 패턴 고도화(Write-Through/Write-Behind)

## 자주 하는 실수

1. 패턴 선택 근거 없이 관성적으로 Cache-Aside만 사용
2. 쓰기/읽기 비율을 측정하지 않고 설계
3. 캐시가 장애 났을 때 폴백 정책 부재

## 요약

- 캐시 패턴은 정답이 아니라 트레이드오프 선택이다.
- 트래픽, 일관성, 장애 전략을 함께 보고 선택해야 한다.

## 연습문제

### 기초

1. Cache-Aside 흐름을 그림으로 표현해보세요.
2. Write-Through의 장단점을 정리해보세요.

### 응용

1. 본인 서비스 API별 캐시 패턴을 매핑해보세요.
2. 패턴 변경 시 리스크 항목을 작성해보세요.

## 챕터 체크리스트

- [x] 초안 작성 완료
- [ ] 예제 명령어 검증 완료
- [x] 초보자 기준 용어 설명 완료
- [x] 최종 교정 완료
